---
import categories from "../data/categories.json";

const categoryNames = Object.keys(categories);
---

<div id="map" class="w-screen h-screen"></div>
<div id="geocoder" class="geocoder fixed top-4 left-4 z-10"></div>
<div
	class="sm:w-[500px] text-sm w-full flex flex-col gap-2 absolute bottom-10 rounded-md z-10 bg-white p-4 left-1/2 transform -translate-x-1/2"
>
	<div>
		<p class="text-md font-semibold" id="title">
			Socio-Economic Classification
		</p>
		<p class="mb-2">Scotland</p>
	</div>
	<div>
		<select id="category" class="w-full p-2 rounded border">
			{
				categoryNames.map((category) => (
					<option value={category}>{category}</option>
				))
			}
		</select>
	</div>
	<div>
		<select id="dataset" class="w-full p-2 rounded border">
			{
				categories[categoryNames[0]].map((option) => (
					<option value={option}>{option}</option>
				))
			}
		</select>
	</div>
	<div>
		<div class="w-full h-4 rounded" id="gradient"></div>
		<div class="flex justify-between">
			<span id="min"></span>
			<span id="max"></span>
		</div>
	</div>
	<div id="hover">Hover over a point to see its value.</div>
</div>

<script>
	import mapboxgl from "mapbox-gl";
	import MapboxGeocoder from "@mapbox/mapbox-gl-geocoder";
	import chroma from "chroma-js";
	import statistics from "../data/statistics.json";
	import keyMapping from "../data/key_mapping.json";
	import categoryMapping from "../data/category_mapping.json";
	import totals from "../data/totals.json";
	import categories from "../data/categories.json";

	const categoryNames = Object.keys(categories);

	const MAPBOX_TOKEN = import.meta.env.PUBLIC_MAPBOX_TOKEN;

	function getColorScale(name) {
		const { low, median, high } = statistics[name];
		return chroma
			.scale(["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"])
			.domain([low, median, high])
			.mode("lch");
	}

	const map = new mapboxgl.Map({
		container: "map",
		style: "mapbox://styles/mapbox/dark-v11",
		center: [-4.2026, 56.4907],
		minZoom: 5,
		maxZoom: 17,
		zoom: 6,
		accessToken: MAPBOX_TOKEN,
		antialias: true,
	});

	const geocoder = new MapboxGeocoder({
		accessToken: MAPBOX_TOKEN,
		mapboxgl: mapboxgl,
	});
	document.getElementById("geocoder").appendChild(geocoder.onAdd(map));

	map.addControl(new mapboxgl.NavigationControl());

	function updateLegend(name) {
		const { low, high } = statistics[name];
		const colorScale = getColorScale(name);
		const gradient = document.getElementById("gradient");
		gradient.style.background = `linear-gradient(to right, ${colorScale.colors(5).join(", ")})`;

		document.getElementById("min").textContent = `${low.toFixed(2)}%`;
		document.getElementById("max").textContent = `${high.toFixed(2)}%`;
	}

	function loadDataset(name) {
		const mappedName = categoryMapping[name];
		const totalKey = totals[mappedName];
		const colorScale = getColorScale(mappedName);

		// Remove existing sources and layers if they exist
		if (map.getLayer("areas")) {
			map.removeLayer("areas");
			map.removeSource("areas");
		}

		if (map.getLayer("intersected")) {
			map.removeLayer("intersected");
			map.removeSource("intersected");
		}

		// Add new sources and layers
		map.addSource("areas", {
			type: "vector",
			tiles: [
				"https://map.jacobweinbren.workers.dev/areas/{z}/{x}/{y}.mvt",
			],
			minzoom: 0,
			maxzoom: 22,
		});

		map.addLayer({
			id: "areas",
			type: "fill",
			source: "areas",
			"source-layer": "areas",
			paint: {
				"fill-color": "rgba(0, 0, 0, 0)",
			},
		});

		map.addSource("intersected", {
			type: "vector",
			tiles: [
				"https://map.jacobweinbren.workers.dev/intersected/{z}/{x}/{y}.mvt",
			],
			minzoom: 0,
			maxzoom: 22,
		});

		map.addLayer({
			id: "intersected",
			type: "fill",
			source: "intersected",
			"source-layer": "intersected",
			paint: {
				"fill-color": [
					"interpolate",
					["linear"],
					[
						"/",
						["to-number", ["get", keyMapping[name]]],
						["to-number", ["get", keyMapping[totalKey]]],
					],
					...colorScale
						.domain()
						.map((d, i) => [d / 100, colorScale.colors(5)[i]]),
				],
			},
		});

		updateLegend(mappedName);
	}

	const categorySelect = document.getElementById("category");
	const datasetSelect = document.getElementById("dataset");

	categorySelect.addEventListener("change", (e) => {
		const category = (e.target as HTMLSelectElement).value;
		datasetSelect.innerHTML = "";
		categories[category].forEach((option) => {
			const optionElement = document.createElement("option");
			optionElement.value = option;
			optionElement.textContent = option;
			datasetSelect.appendChild(optionElement);
		});
		loadDataset(categories[category][0]);
	});

	datasetSelect.addEventListener("change", (e) => {
		const name = (e.target as HTMLSelectElement).value;
		document.getElementById("title").textContent = name;
		loadDataset(name);
	});

	map.on("load", () => loadDataset(categories[categoryNames[0]][0]));
</script>
